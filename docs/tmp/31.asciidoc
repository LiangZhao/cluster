JBoss Cache 简介
----------------
这部分的主要目的是介​绍​JBossCache​基​本​概​念​、​API、​配​置​和部​署，是用户或开发人员能够在​其​项​目​中​快​速​开​始​使​用​JBossCache

1 概 ​述
+++++++

* 1.1 什​么​是JBoss Cache?

  JBoss Cache 是​一​个​树​型​结​构​的​群​集​事​务​性​缓​存​。​它​可​以​用​于​独​立​的​、​非​群​集​的​环​境​里​以​缓​存​内​存​里​被​频​繁访​问​的​数​据​,在​提​供​企​业​级​功​能​如​ JTA 兼​容​性​、​逐​出​和​持​久​化​的​同​时​消​除​了​数​据​提​取​或​计​算​的​瓶​颈​。

  JBoss Cache 也​是​一​个​群​集​缓​存​,它​在​群​集​里​复​制​状​态​,从​而​提​供​高​度​的​失​效​切​换​。​它​支​持​不​同​的​复​制​模​式, 包​括​失​效​和​ Buddy 复​制​,其​网​络​通​讯​既​可​以​是​同​步​也​可​以​是​异​步​的​。

  当​用​于​群​集​模​式​时​, 它​是​在​自​定​义​应​用​程​序​和​框​架​里​构​建​高​可​用​性​、​容​错​和​负​载​平​衡​的​有​效​机​制​。​例​如 JBoss 应​用​服​务​器​在​群​集​服​务​(如 HTTP 和​ EJB 会​话​)里​广​泛​使​用​ JBoss Cache,并​为​ ​JPA ​提​供​了​分​布​式​的​实​体​缓​存​。

  JBoss Cache 要​求​ Java 5.0(或​更​新​版​本​)兼​容​的​虚​拟​机​和​库，除​了​ Java 5.0 以​外​,JBoss Cache 最​少​还​需​要​ JGroups 和​ Apache 的​ commons-logging。​JBoss Cache 附​带​开​箱​即​用​所​需​的​所​有​依​赖​库​,以​及​用​于​可​选​功​能​的​几​个​ JAR 文​件​。

* 1.1.1. 什​么​是 ​POJO Cache?

  POJO Cache 是​核​心​ JBoss Cache API 的​扩​展​。​POJO Cache 提​供​如​下​的​额​外​功​能​:

. 即​使​在​复​制​或​持​久​化​后​仍​维​护​对​象​引​用
. 细​颗​粒​度​的​复​制​,只​复​制​有​改​动​的​对​象​字​段​
. "API-less" 群​集​模​型​,POJO 简​单​地​注​解​为​群​集​

* 1.2. 功能总结

* 1.2.1. 缓存对​象 

  JBoss Cache 提​供​一​个​简​单​和​直​观​的​ API,数​据​ - 简​单​的​ Java 对​象​都​可​以​置​于​缓​存​里​。​基​于​所​选​的​配​置​选项​,这​个​数​据​可​以​是​下​面​的​其​中​一​个​或​全​部​:

. 缓​存​到​内​存​里​以​供​高​效​的​、​线​程​安​全​的​访​问
. 复​制​到​群​集​里​某​些​或​全​部​的​缓​存​实​例​里
. 持​久​化​到​磁​盘​和​/或​远​程​的​内​存​缓​存​群​集​("far-cache")
. 当​空​闲​内​存​过​低​时​进​行​垃​圾​收​集​,并​钝​化​到​磁​盘​以​保​存​状​态​。

  此​外​,JBoss Cache 提​供​一​系​列​丰​富​的​企​业​级​功​能​:

. 能​够​参​与​ JT A 事​务​(和​大​多​数​ Java EE 兼​容​的​事​务​管​理​者​一​起​工​作​)
. 连​接​至​ JMX 控​制​台​并​提​供​缓​存​状​态​的​运​行​时​统​计​信​息​
. 允​许​客​户​代​码​附​加​ listener 并​接​收​缓​存​事​件​的​通​知
. 为​了​高​效​地​复​制​,允​许​缓​存​操​作​分​组​至​批​次

* 1.2.2 本​地​和​群​集​模​式

  缓​存​按​树​型​结​构​组​织​,具​有​唯​一​的​根​。​树​里​的​每​个​节​点​基​本​上​都​包​含​一​个​表​以​存​储​键​/值​对​。​对​缓​存​对​象​的​唯一​要​求​是​它​们​必​须​实​现​ java.io.Serializable。

  JBoss Cache 可​以​是​本​地​的​,也​可​以​是​复​制​性​的​。​本​地​树​只​存​在​创​建​它​们​的​ Java 虚​拟​机​里​,而​复​制​性​树​则把​任​何​修​改​传​递​到​同​一​群​集​里​的​其​他​复​制​性​树​中​。​群​集​可​以​跨​越​网​络​里​的​多​个​主​机​或​者​是​单​个​主​机​里​的​不​同虚​拟​机​。

* 1.2.3 群​集​缓​存​和​事​务

  当​缓​存​里​的​对​象​出​现​修​改​并​发​生​在​事​务​的​上​下​文​里​时​,我​们​会​把​对​修​改​的​复​制​推​迟​,直​到​事​务​成​功​提​交​。​所有​的​修​改​都​保​存​在​一​个​和​调​用​者​使​用​的​事​务​相​关​的​列​表​里​。​当​这​个​事​务​提​交​时​,我​们​将​进​行​复​制​。​否​则​(如回​滚​时​),我​们​只​是​简​单​地​在​本​地​取​消​修​改​并​释​放​任​何​锁​,这​样​就​不​会​有​复​制​相​关​的​通​讯​和​开​销​。例​如​,如果​调​用​者​进​行​了​ 100 个​修​改​然​后​回​滚​事​务​,我​们​不​会​复​制​任​何​数​据​,从​而​不​会​增​加​任​何​网​络​负​载​。

  如​果​调​用​者​没​有​使​用​事​务​或​者​没​有​批​次​与​之​关​联​,我​们​将​在​每​次​修​改​后​马​上​复​制​,例​如​,在​上​面​的​例​子​里​,我​们​将​发​送​ 100 条​消​息​,加​上​一​条​关​于​回​滚​的​额​外​消​息​。​这​样​,不​带​事​务​的​运​行​可​以​被​认​为​和​ JDBC 术​语里​的​启​用​自​动​提​交​类​似​,此​时​的​操​作​都​会​被​自​动​提​交​。

  JBoss Cache 不​做​任​何​修​改​即​可​与​多​数​流​行​的​事​务​管​理​者​一​起​使​用​,它​甚​至​提​供​编​写​自​定​义​事​务​管​理​者​的API。

  上​面​的​内​容​对​于​批​次​也​适​用​,它​具​有​类​似​的​行​为​

* 1.2.4 线程的安全​性 

  JBoss Cache 是​完​全​地​线​程​安​全​的​。​它​使​用​了​多​重​版​本​并​行​控​制​(multi-versioned concurrency control,MVCC)来​确​保​读​取​者​和​写​入​者​间​的​线​程​安​全​性​,同​时​保​持​着​高​度​的​并​行​性​。JBoss Cache 里​使​用的​专​有​ MVCC 实​现​运​行​读​取​者​线​程​完​全​独​立​于​锁​和​同​步​阻​塞​,确​保​了​多​读​应​用​程​序​的​高​性​能​。JBoss Cache 也​使​用​自​定​义​的​、​高​性​能​的​锁​实​现​,它​将​现​代​的​ compare-and-swap 技​术​应​用​于​写​入​者​线​程​,从​而为​多​核​ CPU 架​构​进​行​了​优​化​。

  多​重​版​本​并​行​控​制​(multi-versioned concurrency control,MVCC)是​ JBoss Cache 3.x 之​后​版​本​的​缺​省​锁模​式​。​旧​版​本​的​乐​观​和​悲​观​的​锁​模​式​仍​然​可​用​,但​会​被​ MVCC 所​替​代​,以​后​也​会​从​新​版​本​里​删​除​，不​鼓​励​使​用​这​些​已​取​消​的​锁​模​式​。

  JBoss Cache 的​ MVCC 实​现​只​支​持​ READ_COMMIT T ED 和​ REPEAT ABLE_READ 隔​离​级​别​,分​别​对​应​其数​据​库​里​的​级​别​。​关​于​ MVCC 的​详​情我将在后面介绍。


2. User API
+++++++++++

* 2.1. API 类

Cache 接​口​是​和​ JBoss Cache 交​互​的​主​要​机​制​。​它​是​用​ CacheFactory 构​建​并​可​选​择​地​启​动​的​。CacheFactory 允​许​你​从​ Configuration 对​象​或​ XML 文​件​创​建​ Cache。​缓​存​将​数​据​组​织​到​由​节​点​组成​的​树​型​结​构​里​。​一​旦​你​具​有​了​到​ Cache 的​引​用​,你​可​以​用​它​来​在​树​型​结​构​里​查​找​ Node 对​象​,并​存​储​数据​。

  Figure 3.1

  请​注​意​,上​面​的​图​表​只​是​描​述​了​一​些​流​行​的​ API 方​法​。​阅​读​上​述​接​口​的​ Javadoc 是​学​习​ API 的​最​近​途​径​。

* 2.2. 初始化和启动缓​存 

  Cache 接​口​的​实​例​只​能​通​过​ CacheFactory 创​建​。​这​和​ JBoss Cache 1.x 不​同​,旧​的​ T reeCache 可​以直​接​初​始​化​。

  CacheFactory 提​供​了​用​于​创​建​ Cache 的​大​量​重​载​方​法​,但​它​们​基​本​上​都​是​做​的​同​一​件​事​情​:

. 获​取​对​ Configuration 的​访​问​,或​者​是​作​为​方​法​参​数​传​入​或​通​过​解​析​ XML 内​容​并​进​行​构​建​。​XML 内容​可​以​来​自​输​入​流​、​classpath 或​文​件​系​统​位​置​。​关​于​获​取​ Configuration 的​更​多​信​息​随后将会有详细描述。
. 初​始​化​ Cache 并​为​其​提​供​一​个​对​ Configuration 的​引​用
. 可​选​择​地​调​用​缓​存​的​ create() 和​ start() 方​法​

  下​面​的​例​子​是​使​用​缺​省​配​置​值​创​建​和​启​动​缓​存​的​最​简​单​机​制​:
----
CacheFactory factory = new DefaultCacheFactory();
Cache cache = factory.createCache();
----

  在​这​个​例​子​里​,我​们​告​诉​ CacheFactory 来​查​找​并​解​析​ classpath 上​的​配​置​文​件​:
----
CacheFactory factory = new DefaultCacheFactory();
Cache cache = factory.createCache("cache-configuration.xml");
----

  在​这​个​例​子​里​,我​们​通​过​文​件​配​置​缓​存​,但​希​望​通​过​程​序​修​改​配​置​元​素​。​所​以​,我​们​通​知​工​厂​不​要​启​动​缓​存, 而​是​自​己​来​启​动​:
----
CacheFactory factory = new DefaultCacheFactory();
Cache cache = factory.createCache("/opt/configurations/cache-configuration.xml",
false);
Configuration config = cache.getConfiguration();
config.setClusterName(this.getClusterName());
// Have to create and start cache before using it
cache.create();
cache.start();
----

* 2.3. 缓​存​和​获​取​数​据

  然​后​,让​我​们​使​用​ Cache API 来​访​问​缓​存​里​的​ Node 然​后​对​这​个​节​点​做​一​些​简​单​的​读​和​写​。

----
// Let's get a hold of the root node.
Node rootNode = cache.getRoot();
// Remember, JBoss Cache stores data in a tree structure.
// All nodes in the tree structure are identified by Fqn objects.
Fqn peterGriffinFqn = Fqn.fromString("/griffin/peter");
// Create a new Node
Node peterGriffin = rootNode.addChild(peterGriffinFqn);
// let's store some data in the node
peterGriffin.put("isCartoonCharacter", Boolean.TRUE);
peterGriffin.put("favoriteDrink", new Beer());
// some tests (just assume this code is in a JUnit test case)
assertTrue(peterGriffin.get("isCartoonCharacter"));
assertEquals(peterGriffinFqn, peterGriffin.getFqn());
assertTrue(rootNode.hasChild(peterGriffinFqn));
Set keys = new HashSet();
keys.add("isCartoonCharacter");
keys.add("favoriteDrink");
assertEquals(keys, peterGriffin.getKeys());
// let's remove some data from the node
peterGriffin.remove("favoriteDrink");
assertNull(peterGriffin.get("favoriteDrink");
// let's remove the node altogether
rootNode.removeChild(peterGriffinFqn);
assertFalse(rootNode.hasChild(peterGriffinFqn));
----

  为​了​便​于​使​用​,Cache 接​口​也​开​放​以​『​第 2.4 节 “Fqn 类​”』​参​数​的​ put/get/remove 操​作​:
----
Fqn peterGriffinFqn = Fqn.fromString("/griffin/peter");
cache.put(peterGriffinFqn, "isCartoonCharacter", Boolean.TRUE);
cache.put(peterGriffinFqn, "favoriteDrink", new Beer());
assertTrue(peterGriffin.get(peterGriffinFqn, "isCartoonCharacter"));
assertTrue(cache.getRootNode().hasChild(peterGriffinFqn));
cache.remove(peterGriffinFqn, "favoriteDrink");
assertNull(cache.get(peterGriffinFqn, "favoriteDrink");
cache.removeNode(peterGriffinFqn);
assertFalse(cache.getRootNode().hasChild(peterGriffinFqn));
----

* 2.3.1 组​织​数​据​并​使​用​节​点​结​构

  节​点​应​该​被​看​作​一​个​命​名​逻​辑​数​据​组​。​节​点​应​该​用​来​包​含​单​个​数​据​记​录​里​的​数​据​,例​如​,某​个​人​或​帐​号​的​信息​。​它​应​该​具​有​缓​存​的​所​有​方​面​ - 锁​、​缓​存​加​载​、​复​制​和​逐​出​ - 对​于​每​个​节​点​设​置​。​因​此​,存​储​在​单​个​节​点里​任​何​分​组​信​息​都​将​被​当​作​单​个​的​原​子​单​元​。

* 2.4. Fqn 类

  前​面​的​部分​在​其​示​例​里​使​用​了​ Fqn 类​;现​在​让​我​们​对​其​进​行​进​一​步​的​了​解​。

  Fully Qualified Name (Fqn) 封​装​了​代​表​对​应​缓​存​树​型​机​构​里​某​个​位​置​的​路​径​的​名​称​列​表​。​该​列​表​里​的​元​素​通常​是​ String 但​也​可​以​是​任​何​ Object 或​混​合​类​型​。

  这​个​路​径​可​以​是​绝​对​的​(也​就​是​相​对​于​根​节​点​),也​可​以​相​对​于​缓​存​里​的​任​何​节​点​。​关​于​使​用​ Fqn 的​ API调​用​的​文​档​里​会​告​诉​你​该​ API 是​否​使​用​相​对​还​是​绝​对​的​ Fqn。

  Fqn 提​供​了​大​量​的​工​厂​方​法​;详​情​请​参​考​ Javadoc。​下​面​的​例​子​解​释​了​创​建​ FQN 最​常​用​的​途​径​:
----
// Create an Fqn pointing to node 'Joe' under parent node 'Smith'
// under the 'people' section of the tree
// Parse it from a String
Fqn abc = Fqn.fromString("/people/Smith/Joe/");
// Here we want to use types other than String
Fqn acctFqn = Fqn.fromElements("accounts", "NY", new Integer(12345));
----

  请​注​意​:
----
Fqn f = Fqn.fromElements("a", "b", "c");
----
  相​等​于​:
----
Fqn f = Fqn.fromString("/a/b/c");
----

* 2.5. 停​止​和​销​毁​缓​存

  使​用​完​毕​后​停​止​并​销​毁​缓​存​是​一​个​好​的​做​法​,特​别​是​在​群​集​缓​存​并​加​上​对​ JGroups 频​道​的​使​用​的​情​况​下​。停​止​并​销​毁​缓​存​确​保​了​能​够​正​确​地​清​理​网​络​套​接​字​和​维​护​线​程​等​资​源​。
----
cache.stop();
cache.destroy();
----

  请​注​意​,已​调​用​ stop() 的​缓​存​可​以​用​ start() 重​启​启​动​。​类​似​地​,已​调​用​ destroy() 的​缓​存​也​可​以​用 create() 重​新​创​建​(并​可​用​ start() 调​用​重​启​启​动​)。

* 2.6. 缓存模式 

  虽​然​从​技​术​上​来​说​并​非​ API 的​一​部​分​,但​缓​存​所​操​作​的模式​可​影​响​到​任​何​ put 或​ remove 操​作​的​行​为​,所以​在​这​里​我​们​将​简​单​地​提​及​这​些​模​式​。

  JBoss Cache 是​通​过​ org.jboss.cache.config.Configuration.CacheMode 枚​举​的​。它​们​是​:

. LOCAL - 本​地​的​、​非​群​集​的​缓​存​。​本​地​缓​存​不​加​入​群​集​也​不​和​群​集​里​的​其​他​节​点​通​讯​。
. REPL_SYNC - 同​步​复​制​。​缓​存​复​制​群​集​里​其​他​缓​存​的​修​改​。​同​步​复​制​意​味​着​修​改​被​复​制​且​调​用​者​阻​塞​, 直​至​接​收​到​复​制​确​认​
. REPL_ASYNC - 异​步​复​制​。​和​上​面​的​ REPL_SYNC 类​似​,缓​存​复​制​群​集​里​其​他​缓​存​的​修​改​。​但​调​用​者​不会​阻​塞​到​接​收​到​复​制​确​认​为​止​。
. INVALIDATION_SYNC - 如​果​缓​存​被​配​置​为​失​效​而​不​是​复​制​,每​次​数​据​有​修​改​时​,群​集​里​的​其​他​缓​存​将收​到​一​条​消​息​来​通​知​它​们​这​个​数​据​已​经​陈​旧​且​应​该​从​内​存​逐​出​。​这​样​做​减​少​了​复​制​负​载​,同​时​还​可​以​使远​程​缓​存​里​的​陈​旧​数​据​失​效​。
. INVALIDATION_ASYNC - 和​上​面​的​一​样​,除​了​这​个​失​效​模​式​会​导​致​失​效​信​息​的​异​步​广​播​

* 2.7. 添​加​缓​存​Listener-注​册​缓​存​事​件

  JBoss Cache 提​供​一​个​方​便​的​机​制​以​注​册​缓​存​事​件​的​通​知​。
----
Object myListener = new MyCacheListener();
cache.addCacheListener(myListener);
----

  删​除​或​查​询​注​册​的​ listener 也​有​类​似​的​方​法​。​详​情​请​参​考​ Cache 接​口​的​ Javadoc

  如​果​用​ @CacheListener 进​行​注​解​,基​本​上​任​何​的​公​用​类​都​可​用​作​ listener。​此​外​,类​的​一​个​或​多​个​方​法需​要​进​行​方​法​级​别​的​注​解​(在​ org.jboss.cache.notifications.annotation 软​件​包​里​)。​被​注解​方​法​需​要​是​ public 的​,并​具​有​ void 返​回​类​型​,还​得​接​受org.jboss.cache.notifications.event.Event 类​型​或​其​子​类​型​为​唯​一​的​参​数​。

. @CacheStarted - 注​解​方​法​以​在​缓​存​启​动​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 CacheStartedEvent 的​参​数​类​型​。
. @CacheStopped - 注​解​方​法​以​在​缓​存​停​止​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 CacheStoppedEvent 的​参​数​类​型​。
. @NodeCreated - 注​解​方​法​以​在​节​点​创​建​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeCreatedEvent 的​参​数​类​型​。
. @NodeRemoved - 注​解​方​法​以​在​删​除​节​点​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeRemovedEvent 的​参​数​类​型​。
. @NodeModified - 注​解​方​法​以​在​修​改​节​点​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeModifiedEvent 的​参​数​类​型​。
. @NodeMoved - 注​解​方​法​以​在​移​动​节​点​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于​ NodeMovedEvent 的参​数​类​型​。
. @NodeVisited - 注​解​方​法​以​在​访​问​节​点​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeVisitedEvent 的​参​数​类​型​。
. @NodeLoaded - 注​解​方​法​以​在​从​ CacheLoader 里​加​载​节​点​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeLoadedEvent 的​参​数​类​型​。
. @NodeEvicted - 注​解​方​法​以​在​节​点​从​内​存​里​逐​出​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeEvictedEvent 的​参​数​类​型​。
. @NodeInvalidated - 注​解​方​法​以​在​节​点​由​于​远​程​失​效​事​件​从​内​存​里​逐​出​时​接​收​通​知​。​这​些​方​法​需​要接​受​一​个​属​于​ NodeInvalidatedEvent 的​参​数​类​型​。
. @NodeActivated - 注​解​方​法​以​在​节​点​被​激​活​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodeActivatedEvent 的​参​数​类​型​。
. @NodePassivated - 注​解​方​法​以​在​节​点​被​钝​化​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 NodePassivatedEvent 的​参​数​类​型​。
. @TransactionRegistered - 注​解​方​法​以​在​缓​存​在​已​注​册​的​事​务​管​理​者​里​注​册 javax.transaction.Synchronization 时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于  TransactionRegisteredEvent 的​参​数​类​型​。
. @TransactionCom pleted - 注​解​方​法​以​在​缓​存​从​已​注​册​的​事​务​管​理​者​接​收​提​交​或​回​滚​调​用​时​接​收​通知​。​这​些​方​法​需​要​接​受​一​个​属​于​ TransactionCom pletedEvent 的​参​数​类​型​。
. @ViewChanged - 注​解​方​法​以​在​群​集​的​组​结​构​改​变​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于 ViewChangedEvent 的​参​数​类​型​。
. @CacheBlocked - 注​解​方​法​以​在​缓​存​操​作​因​为​状​态​转​换​事​件​而​阻​塞​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一个​属​于​ CacheBlockedEvent 的​参​数​类​型​。
. @CacheUnblocked - 注​解​方​法​以​在​缓​存​操​作​因​为​状​态​转​换​事​件​而​取​消​阻​塞​时​接​收​通​知​。​这​些​方​法​需​要接​受​一​个​属​于​ CacheUnblockedEvent 的​参​数​类​型​。
. @BuddyGroupChanged - 注​解​方​法​以​在​节​点​由​于​ Buddy 放​弃​群​集​或​更​新​、​更​近​的​ Buddy 加​入​而​修​改其​ Buddy 组​时​接​收​通​知​。​这​些​方​法​需​要​接​受​一​个​属​于​ BuddyGroupChangedEvent 的​参​数​类​型​。

  请​参​考​ Javadocs 了​关​于​注​解​和​ Event 子​类​型​的​内​容​,如​传​入​方​法​里​的​参​数​是​什​么​、​何​时​传​入​等​。

Demo 3.1
----
@CacheListener
public class MyListener
{
@CacheStarted
@CacheStopped
public void cacheStartStopEvent(Event e)
{
switch (e.getType())
{
case CACHE_STARTED:
System.out.println("Cache has started");
break;
case CACHE_STOPPED:
System.out.println("Cache has stopped");
break;
}
}
@NodeCreated
@NodeRemoved
@NodeVisited
@NodeModified
@NodeMoved
public void logNodeEvent(NodeEvent ne)
{
log("An event on node " + ne.getFqn() + " has occured");
}
}
----

* 2.7.1. 同​步​和​异​步​通​知
  在​缺​省​情​况​下​,所​有​的​通​知​都​是​同​步​的​,因​此​它​们​在​产​生​事​件​的​调​用​者​线​程​里​发​生​。​确​保​缓​存​ listener 实​现不​会​占​用​需​长​时​间​运​行​的​任​务​中​的​线​程​是​一​个​好​的​办​法​。​或​者​,你​可​以​设​置​ CacheListener.sync 属​性为​ false,此​时​你​不​会​在​调​用​者​线​程​里​得​到​通​知​。

* 2.8 用缓存加载​器

  缓​存​加​载​器​是​ JBoss Cache 的​重​要​组​成​部​分​。​它​们​允​许​节​点​持​久​化​到​磁​盘​或​远​程​缓​存​群​集​里​,而​且​允​许​在缓​存​用​尽​内​存​时​进​行​钝​化​。​此​外​,缓​存​加​载​器​允​许​ JBoss Cache 执​行​“​warm starts”​,此​时​的​内​存​状​态​可​以从​持​久​性​存​储​中​预​加​载​。​JBoss Cache 附​带​了​大​量​的​缓​存​加​载​器​实​现​。

. org.jboss.cache.loader.FileCacheLoader - 是​一​个​基​本​的​、​基​于​文​件​系​统​的​缓​存​加​载​器​,它将​数​据​持​久​化​到​磁​盘​。​它​是​非​事​务​性​的​,而​且​性​能​一​般​,单​确​实​非​常​简​单​的​方​案​。​它​主​要​用​于​测​试​,不​推​荐​将​其​用​在​产​品​环​境​中​。
. org.jboss.cache.loader.JDBCCacheLoader - 它​使​用​ JDBC 连​接​来​存​储​状​态​。​连​接​可​从​一​个内​部​池​(使​用​ c3p0 pooling 库​)或​配​置​好​的​数​据​源​里​创​建​并​维​护​。​这​个​缓​存​加​载​器​连​接​的​数​据​库​可​以​是本​地​的​,也​可​以​是​远​程​的​。
. org.jboss.cache.loader.BdbjeCacheLoader - 它​使​用​ Oracle 的​基​于​文​件​的​ BerkeleyDB 事务​性​数​据​库​来​持​久​化​数​据​。​它​是​事​务​性​的​,而​且​性​能​非​常​好​,但​可​能​具​有​受​限​的​许​可​证​。
. org.jboss.cache.loader.Jdbm CacheLoader - BerkeleyDB 的​开​源​替​代​方​案​。
. org.jboss.cache.loader.tcp.T cpCacheLoader - 通​过​『​一​种​ "far cache" 模​式​』​使​用​ TCP 套​接​字​来​“​持​久​化​”​数​据​到​远​程​群​集​里​。
. org.jboss.cache.loader.ClusteredCacheLoader - 用​作​“​只​读​”​缓​存​加​载​器​,此​时​群​集​里​的​其他​节​点​按​状​态​查​询​。​当​完​整​状​态​转​移​的​代​价​过​高​时​,它​就​是​首​选​的​,此​时​状​态​是​ lazy 加​载​的​。

* 2.9 使用逐出策略(Eviction Policy)

  逐​出​策​略​是​缓​存​加​载​器​的​对​应​物​。​要​确​保​缓​存​在​填​充​时​不​会​用​尽​内​存​,使​用​逐​出​策​略​是​必​要​的​。​在​独​立​线​程里​运​行​的​逐​出​算​法​逐​出​内​存​状​态​并​释​放​内​存​。​如​果​配​有​缓​存​加​载​器​,在​需​要​时​状​态​可​以​从​缓​存​加​载​器​里​获​得。

  逐​出​策​略​可​对​每​个​区​进​行​配​置​,所​以​缓​存​里​不​同​的​子​树​可​以​有​不​同​的​逐​出​首​选​项​。​JBoss Cache 附​带​几​个​注册​策​略​:

. org.jboss.cache.eviction.LRUPolicy - 当​到​达​极​限​时​逐​出​最​近​最​少​使​用​的​节​点​。
. org.jboss.cache.eviction.LFUPolicy - 当​到​达​极​限​时​逐​出​最​不​经​常​使​用​的​节​点​。
. org.jboss.cache.eviction.MRUPolicy - 当​到​达​极​限​时​逐​出​最​近​使​用​最​多​的​节​点​。
. org.jboss.cache.eviction.FIFOPolicy - 当​到​达​极​限​时​按​照​先​入​先​出​顺​序​逐​出​节​点​。
. org.jboss.cache.eviction.ExpirationPolicy - 基​于​每​个​节​点​配​置​的​过​期​时​间​逐​出​节​点​的​策略​。
. org.jboss.cache.eviction.Elem entSizePolicy - 根​据​节​点​保​持​的​键​/值​数​量​选​择​节​点​逐​出​的策​略​。


3. 配置
+++++++

* 3.1 配置概述

  org.jboss.cache.config.Configuration 类​(及​其​第 3.3 节 “Configuration 对​象​的​构​成​”)是​封​装​了​ Cache 及​其​所​有​构​架​元​素​(类​加​载​器​、​逐​出​策​略​等​)的​ Java Bean。

  Configuration 开​放​了​大​量​的​属​性​,本​书​的​后​续​章​节​里​讨​论​的内​容​对​此​进​行​了​总​结​。​每​当​你​看​到​本​书​里​讨​论​的​配​置​选​项​,你​可​以​假​设​ Configuration 类​或​其​组​件​部​分为​该​配​置​选​项​开​放​了​简​单​的​属​性​ setter/getter 方​法​。

* 3.2. 创​建​ Configuration

  如之前我们所​讨​论​的​,在​可​以​创​建​ Cache 之​前​,必​须​提​供​ CacheFactory 以及​ Configuration 对​象​或​文​件​名​称​或​输​入​流​以​从​ XML 里​解​析​ Configuration。​下​面​我们​讨​论​了​如何​来​实​现​这​一​点​。

* 3.2.1 解​析​基​于​XML的​配​置​文​件

  配​置​ JBoss Cache 最​简​单​的​方​法​是​通​过​一​个​ XML 文​件​。​JBoss Cache 附​带​大​量​的​用​于​常​见​用​例​的​配​置​文件​。​我​们​推​荐​将​这​些​文​件​用​作​起​点​参​考​,并​进​行​调​整​以​满​足​特​殊​的​需​要​。

  下​面​是​一​个​最​简​单​的​ XML 配​置​文​件​,它​配​置​缓​存​以​本​地​(LOCAL)模​式​运​行​:
----
<?xml version="1.0" encoding="UTF-8"?>
<jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1">
</jbosscache>
----

  对​于​隔​离​级​别​、​锁​获​取​超​时​、​锁​模​式​等​这​个​文​件​使​用​缺​省​值​。​本​书​的​『​第 12.1 节 “XML 配​置​文​件​示​例​”』​以及​『​第 12.2 节 “配​置​文​件​快​速​引​用​”』​章​节​里​包​括​的​另​外​一​个​更​完​整​的​ XML 文​件​解​释​了​不​同​的​选​项​。

* 3.2.2 检​验​配​置文​件 

  在​缺​省​情​况​下​,JBoss Cache 将​根​据​ XML 模​式​检​验​你​的​ XML 文​件​,如​果​配​置​无​效​则​抛​出​异​常​。​这​可​以​通​过-Djbosscache.config.validate=false JVM 参​数​覆​盖​。​或​者​,你​可​以​用​ -Djbosscache.config.schem aLocation=url 参​数​定​自​己​的​模​式​来​进​行​检​验​。

  而​在​缺​省​情​况​下​,配​置​文​件​是​根​据​ JBoss Cache 配​置​模​式​进​行​检​验​的​,它​位​于​ jbosscache-core.jar 或​ http://www.jboss.org/jbosscache/jbosscache-config-3.0.xsd 上​。​大​多​数​的​ XML 编​辑工​具​可​以​和​这​个​模​式​一​起​使​用​以​确​保​你​创​建​的​配​置​文​件​是​正​确​且​有​效​的​。

* 3.2.3 通​过​程​序​配​置

  除​了​上​面​的​基​于​ XML 配​置​外​, Configuration 也​可​以​使​用​ Configuration 和​其​组​件​开​放​的​简​单​属​性在​程​序​里​进​行​构​建​。​在​进​行​构​建​时​,Configuration 对​象​和​ JBoss Cache 缺​省​值​一​起​出​现​,甚​至​可​用​作快​速​启​动​配​置​。

----
Configuration config = new Configuration();
config.setTransactionManagerLookupClass(
GenericTransactionManagerLookup.class.getName()
);
config.setIsolationLevel(IsolationLevel.READ_COMMITTED);
config.setCacheMode(CacheMode.LOCAL);
config.setLockAcquisitionTimeout(15000);
CacheFactory factory = new DefaultCacheFactory();
Cache cache = factory.createCache(config);
----

  甚​至​上​面​相​当​简​单​的​配​置​也​是​乏​味​的​编​程​; 因​此​使​用​基​于​ XML 配​置​是​首​选​的​办​法​。​然​而​,如​果​你​的​应​用​程序​需​要​它​, 那​没​有​理​由​对​大​部​分​属​性​不​使​用​基​于​ XML 配​置​, 然​后​访​问​ Configuration 对​象​在​程​序​里​修​改一​些​缺​省​值​、​添​加​逐​出​域​等​。

  请​注​意​,当​缓​存​在​运​行​时​,配​置​值​可​能​无​法​在​程​序​里​修​改​, 除​了​注​解​为​ @Dynamic 的​配​置​。​动​态​属​性​也​在『​第 12.2 节 “配​置​文​件​快​速​引​用​”』​表​里​进​行​标​注​。​试​图​修​改​非​动​态​属​性​将​导​致ConfigurationException。

* 3.3 Configuration 对​象​的​构​成

  Configuration 由​大​量​的​子​对​象​构​成​:

  Figure 3.2

  下​面​是​ Configuration 组​件​的​简​单​概​述​。​关​于​和​每​个​组​件​相​关​的​配​置​的​详​细​解​释​,请​参​考​ Javadoc 和​本书​相​关​的​章​节​。
. Configuration: 层​次​结​构​里​的​顶​层​对​象​; 它​开​放​本​书​『​第 12.2 节 “配​置​文​件​快​速​引​用​”』​章​节​里​列​出详细的​配​置​属​性​。
. BuddyReplicationConfig: 仅​当​使​用​『​第 8.1.2.2 节 “Buddy 复​制​”』​时​才​相​关​。​它​是​常​用​的​复​制​配置​选​项​。​它​必​须​包​括​:
.. BuddyLocatorConfig: 用​于​ BuddyLocator 实​现​的​专​有​配​置​对​象​。​开​放​哪​些​配​置​元​素​取​决​于 BuddyLocator 实​现​的​需​要​。
. EvictionConfig: 只​在​使​用​『​第 10 章 逐出(Eviction)』​时​才​相​关​。​它​是​常​用​的​逐​出​配​置​选​项​。​它必​须​包​含​至​少​一​个​下​面​的​元​素​:
.. EvictionRegionConfig: 每​个​逐​出​区​具​有​一​个​;它​为​区​命​名​。​它​必​须​包​括​:
... EvictionAlgorithmConfig: 用​于​所​使​用​的​ EvictionAlgorithm 实​现​的​专​有​配​置​对​象​。​开​放​哪些​配​置​元​素​取​决​于​ EvictionAlgorithm 实​现​的​需​要​。
. CacheLoaderConfig: 只​有​使​用​『​第 9 章 缓存加载器​』​时​才​相​关​。​它​是​通​用​的​缓​存​加​载​器​配​置​选​项。​它​必​须​包​括​至​少​一​个​下​面​的​配​置​:
.. IndividualCacheLoaderConfig: 用​于​所​使​用​的​ CacheLoader 实​现​的​专​有​配​置​对​象​。​开​放​哪​些配​置​元​素​取​决​于​ CacheLoader 实​现​的​需​要​。
. RuntimeConfig:向​缓​存​客​户​开​放​关​于​运​行​环​境​(使​用​『​xref linkend="br" />』​时​ Buddy 复​制​组​里​的成​员​资​格​)的​信​息​。​它​也​允​许​对​所​需​的​外​部​服​务​如​ JTA TransactionManager 或​ JGroups ChannelFactory 的​缓​存​进​行​直​接​注​入​。

* 3.4 动态重配置

  当​缓​存​在​运​行​时​,你​可​以​动​态​地​修​改​ some 选​项​的​配​置​:通​过​程​序​从​运​行​中​的​缓​存​里​获​得 Configuration 对​象​并​修​改​如​下​值​:
----
Configuration liveConfig = cache.getConfiguration();
liveConfig.setLockAcquisitionTimeout(2000);
----

 『​第 12.2 节 “配​置​文​件​快​速​引​用​”』​里​关​于​哪​些​选​项​可​以​动​态​修​改​的​完​整​列​表​。​如​果​你​试​图​修​改​一​个​非​动​态的​设​置​,org.jboss.cache.config.ConfigurationException 将​被​抛​出​。

* 3.4 .1 通过 Option API 覆盖配​置 

  Option API 允​许​你​覆​盖​每​一​个​调​用​的​缓​存​行​为​。​这​包​括​创​建​ org.jboss.cache.config.Option 实​例, 在​ Option 对​象​设​置​你​需​要​覆​盖​的​选​项​并​在​调​用​方​法​前​作​为​参​数​传​递​给​ InvocationContext。

  例​如​,当​读​取​数​据​(当​用​在​事​务​时​,这​和​数​据​库​里​的​ SELECT FOR UPDAT E 模​式​类​似​)时​强​制​写​锁​。
----
// first start a transaction
cache.getInvocationContext().getOptionOverrides().setForceWriteLock(true);
Node n = cache.getNode(Fqn.fromString("/a/b/c"));
// make changes to the node
// commit transaction
----

  例​如​,抑​制​ REPL_SYNC 缓​存​里​的​ put 调​用​的​复​制​:
----
Node node = cache.getChild(Fqn.fromString("/a/b/c"));
cache.getInvocationContext().getOptionOverrides().setLocalOnly(true);
node.put("localCounter", new Integer(2));
----

关​于​ Option 类​的​选​项​细​节​,请​参​考​ Javadocs。


4 Batching API
++++++++++++++

* 4.1 简介 

  JBoss Cache 3.x 里​引​入​的​ Batching API,是​批​处​理​独​立​于​ JTA 事​务​的​调​用​的​一​个​机​制​。

  当​你​想​在​比​正​在​运​行​的​ JT A 事​务​更​细​的​作​用​域​里​批​处​理​复​制​调​用​时​,这​是​很​有​用​的​。

* 4.2 配置批处理 

  要​使​用​批​处​理​,你​需​要​在​缓​存​配​置​或​ Configuration 对​象​里​启​用​调​用​批​处​理​:
----
Configuration.setInvocationBatchingEnabled(true);
----
  或​在​ XML 文​件​里​:
----
<invocationBatching enabled="true"/>
----
  在​缺​省​情​况​下​,调​用​的​批​处​理​是​禁​用​的​。​请​注​意​,使​用​批​处​理​你不​需​要​定​义​事​务​管​理​者​。

* 4.3. Batching API

  一​旦​你​已​经​配​置​了​缓​存​来​使​用​批​处​理​,你​可​以​通​过​调​用​ Cache 上​的​ startBatch() 和​ endBatch() 来​使用​它​。​例​如​:
----
Cache cache = getCache();
// not using a batch
cache.put("/a", "key", "value"); // will replicate immediately
// using a batch
cache.startBatch();
cache.put("/a", "key", "value");
cache.put("/b", "key", "value");
cache.put("/c", "key", "value");
cache.endBatch(true); // This will now replicate the modifications since the
batch was started.
cache.startBatch();
cache.put("/a", "key", "value");
cache.put("/b", "key", "value");
cache.put("/c", "key", "value");
cache.endBatch(false); // This will "discard" changes made in the batch
----
  
5 部署 ​JBoss Cache
++++++++++++++++++

* 5.1 独​立​使​用​/在​程​序​里​进​行​部​署

  如​『​第 2.2 节 “初​始​化​和​启​动​缓​存​”』​和​『​第 3.2 节 “创​建​ Configuration”』​章​节​所​讨​论​的​,当​用​于​独​立​的 Java 程​序​里​时​, 要​做​的​只​是​用​ CacheFactory 和​ Configuration 实​例​或​ XML 文​件​初​始​化​缓​存​。

  当​运​行​在​应​用​服​务​器​里​的​应​用​程​序​希​望​部​署​缓​存​而​不​是​依​赖​于​应​用​服​务​器​的​部​署​功​能​时​,也​可​以​使​用​相​同​的技​术​。​通​过​ javax.servlet.ServletContextListener 部​署​缓​存​的​ webapp 是​其​中​一​个​例​子​。

  创​建​之​后​,你​可​以​通​过​ IOC 容​器​(如​ JBoss 微​容​器​)、​绑​定​ JNDI 或​简​单​地​持​有​对​缓​存​的​静​态​引​用​在​不​同​的应​用​程​序​组​件​间​分​享​你​的​缓​存​实​例​。

  如​果​在​部​署​缓​存​后​你​希​望​向​它​开​放​ JMX 里​的​管​理​接​口​, 请​参​考​『​第 5.4.2 节 “用​ MBeanServer 注​册 CacheJmxWrapper”』​。

* 5.2 通过 ​JBoss 微容器(JBoss AS 5.x)

  从​ AS 5 开​始​, JBoss AS 支​持​通​过​名​字​以​ -jboss-beans.xm l 结​尾​的​文​件​来​部​署​ POJO 服​务​。​POJO 服务​是​通​过​简​单​的​ Java 对​象​(Plain Old Java Object)实​现​的​,表​示​不​需​要​实​现​任​何​特​殊​接​口​或​继​承​任​何​特​定超​类​的​简​单​ Java bean。​Cache 是​一​个​ POJO 服​务​, Configuration 里​的​所​有​组​件​也​是​ POJO,所​以​以这​种​方​式​部​署​缓​存​是​一​个​自​然​的​步​骤​。

  缓​存​的​部​署​是​通​过​组​成​ JBoss AS 核​心​的​ JBoss 微​容​器​实​现​的​。​ JBoss 微​容​器​是​一​个​和​ Spring 类​似​的​复​杂的​ IOC 框​架​。​-jboss-beans.xm l 文​件​基​本​上​是​一​个​描​述​符​,它​告​诉​ ICO 框​架​如​何​组​装​组​成​ POJO 服​务的​不​同​的​ bean。

  对​于​ Configuration 组​件​开​放​的​每​个​可​配​置​选​项​,你​必​须​在​ configuration 类​里​定​义​ getter/setter。​这​样对​于​已​配​置​的​属​性​, JBoss 微​容​器​才​能​以​典​型​的​ IOC 方​式​调​用​相​应​的​方​法​。

  你​需​要​确​保​ jbosscache-core.jar 和​ jgroups.jar 库​都​位​于​你​的​服​务​器​的​ lib 目​录​。​当​你​以​ all 配​置​使​用​ JBoss AS 通​常​就​是​这​样​。​请​注​意​, 你​得​注​明​你​需​要​的​任​何​可​选​ JAR, 如​基​于​缓​存​配​置​的jdbm.jar。

  下​面​是​一​个​示​例​ -beans.xm l 文​件​。​如​果​你​查​看​ JBoss AS 5 的​ server/all/deploy 目​录​,你​会​看​到更​多​的​例​子​。
----
<?xml version="1.0" encoding="UTF-8"?>
<deployment xmlns="urn:jboss:bean-deployer:2.0">
<!-- First we create a Configuration object for the cache -->
<bean name="ExampleCacheConfig"
class="org.jboss.cache.config.Configuration">
<!-- Externally injected services -->
<property name="runtimeConfig">
<bean class="org.jboss.cache.config.RuntimeConfig">
<property name="transactionManager">
<inject bean="jboss:service=TransactionManager"
property="TransactionManager"/>
</property>
<property name="muxChannelFactory"><inject
bean="JChannelFactory"/></property>
</bean>
</property>
<property name="multiplexerStack">udp</property>
<property name="clusterName">Example-EntityCache</property>
<property name="isolationLevel">REPEATABLE_READ</property>
<property name="cacheMode">REPL_SYNC</property>
<property name="stateRetrievalTimeout">15000</property>
<property name="syncReplTimeout">20000</property>
<property name="lockAcquisitionTimeout">15000</property>
<property name="exposeManagementStatistics">true</property>
</bean>
<!-- Factory to build the Cache. -->
<bean name="DefaultCacheFactory" class="org.jboss.cache.DefaultCacheFactory">
<constructor factoryClass="org.jboss.cache.DefaultCacheFactory"
factoryMethod="getInstance" />
</bean>
<!-- The cache itself -->
<bean name="ExampleCache" class="org.jboss.cache.Cache">
<constructor factoryMethod="createCache">
<factory bean="DefaultCacheFactory"/>
<parameter class="org.jboss.cache.config.Configuration"><inject
bean="ExampleCacheConfig"/></parameter>
<parameter class="boolean">false</parameter>
</constructor>
</bean>
</deployment>
----

  对​于​上​面​涉​及​的​语​法​,请​参​考​ JBoss 微​容​器​文​档​ [1]​。​基​本​上​, 每​个​ bean 元​素​都​代​表​一​个​用​于​创​建 Configuration 及​其​ 第 3.3 节 “Configuration 对​象​的​构​成​” 的​对​象​。​DefaultCacheFactory bean 构​建​缓​存​,从​概​念​上​来​说​它​完​成​和​『​第 2.2 节 “初​始​化​和​启​动​缓​存​”』​章​节​所​展​示​的​相​同​的​事​情​。

  上​面​的​例​子​里​的​一​件​有​趣​的​事​情​是​对​ Runtim eConfig 对​象​的​使​用​。​外​部​的​资​源​,如​微​容​器​可​见​的 TransactionManager 和​ JGroups ChannelFactory 都​依​赖​性​注​入​到​ RuntimeConfig 里​。​这​里​假定​在​ AS 里​的​其​他​部​署​描​述​符​里​,已​经​对​被​引​用​的​ bean 进​行​了​描​述​。

* 5.3 运​行​时​管​理​信​息

  JBoss Cache 包​含​ JMX MBean 来​开​放​缓​存​功​能​并​提​供​用​来​分​析​缓​存​操​作​的​统​计​信​息​。​JBoss Cache 也​可以​把​缓​存​事​件​作​为​通​过​ JMX 监​控​工​具​处​理​的​ MBean 通​知​广​播​。

* 5.3.1 JBoss Cache MBean

  JBoss Cache 提​供​一​个​可​以​将​向​你​的​环​境​ JMX 服​务​器​注​册​的​ MBean, 它​允​许​通​过​ JMX 访​问​缓​存​实​例​。​这个​ MBean 是​ org.jboss.cache.jmx.CacheJmxWrapper。​它​是​一​个​标​准​的​ MBean, 所​以​它​的 MBean 接​口​是​ org.jboss.cache.jmx.CacheJmxWrapperMBean。​它​可​用​于​:
. 获​得​对​底​层​ Cache 的​引​用​。
. 调​用​底​层​ Cache 的​ create/start/stop/destroy 生​命​周​期​操​作​
. 查​看​关​于​缓​存​的​当​前​状​态​的​细​节​(节​点​数​目​、​锁​信​息​等​)
. 查​看​缓​存​配​置​的​细​节​,并​修​改​那​些​可​以​在​缓​存​启​动​后​修​改​的​配​置

  关​于​更​多​的​细​节​,请​查​看​ CacheJm xWrapperMBean Javadoc。

  如​果​注​册​了​ CacheJmxWrapper,JBoss Cache 也​为​其​他​几​个​内​部​组​件​和​子​系​统​提​供​ MBean。​这​些 MBean 被​用​来​捕​获​和​开​放​和​缓​存​相​关​的​统​计​信​息​。​它​们​和​ CacheJmxWrapper MBean 之​间​有​着​分​层​的​关联​, 其​名​字​反​映​了​这​种​关​系​。​例​如​, jboss.cache:service=TomcatClusteringCache 实​例​的 replication interceptor MBean 将​可​以​通​过 jboss.cache:service=TomcatClusteringCache, cache-interceptor=ReplicationInterceptor 进​行​访​问​。

* 5.3.2 用​ MBeanServer 注册​ CacheJmxWrapper
  
  确​保​ CacheJm xWrapper 在​ JMX 里​注​册​的​最​好​办​法​依​赖​于​部​署​缓​存​的​方​式​。


* 5.3.2.1 用 ​Cache 实​例​在​程​序​里​进​行​注​册

  最​简​单​的​方​法​是​创​建​你​的​ Cache 并​传​递​给​ Jm xRegistrationManager 构​造​器​
----
CacheFactory factory = new DefaultCacheFactory();
// Build but don't start the cache
// (although it would work OK if we started it)
Cache cache = factory.createCache("cache-configuration.xml");
MBeanServer server = getMBeanServer(); // however you do it
ObjectName on = new ObjectName("jboss.cache:service=Cache");
JmxRegistrationManager jmxManager = new JmxRegistrationManager(server, cache,
on);
jmxManager.registerAllMBeans();
... use the cache
... on application shutdown
jmxManager.unregisterAllMBeans();
cache.stop();
----

* 5.3.2.2 用​ Configuration 实​例​在​程​序​里​注​册

  CacheJmxWrapper 是​一​个​ POJO, 所​以​微​容​器​创​建​它​不​会​有​什​么​问​题​。​其​中​的​窍​门​是​让​它​在​ JMX 里​注​册。​这​可​通​过​指​定​ CacheJmxWrapper bean 上​的org.jboss.aop.m icrocontainer.aspects.jmx.JMX 注​解​来​完​成​
----
<?xml version="1.0" encoding="UTF-8"?>
<deployment xmlns="urn:jboss:bean-deployer:2.0">
<!-- First we create a Configuration object for the cache -->
<bean name="ExampleCacheConfig"
class="org.jboss.cache.config.Configuration">
... build up the Configuration
</bean>
<!-- Factory to build the Cache. -->
<bean name="DefaultCacheFactory" class="org.jboss.cache.DefaultCacheFactory">
<constructor factoryClass="org.jboss.cache.DefaultCacheFactory"
factoryMethod="getInstance" />
</bean>
<!-- The cache itself -->
<bean name="ExampleCache" class="org.jboss.cache.CacheImpl">
<constructor factoryMethod="createnewInstance">
<factory bean="DefaultCacheFactory"/>
<parameter><inject bean="ExampleCacheConfig"/></parameter>
<parameter>false</parameter>
</constructor>
</bean>
<!-- JMX Management -->
<bean name="ExampleCacheJmxWrapper"
class="org.jboss.cache.jmx.CacheJmxWrapper">
<annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="jboss.cache:service=
ExampleTreeCache",
exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class,
registerDirectly=true)</annotation>
<constructor>
<parameter><inject bean="ExampleCache"/></parameter>
</constructor>
</bean>
</deployment>
----

  如​『​第 5.3.2 节 “用​ MBeanServer 注​册​ CacheJmxWrapper”』​里​所​讨​论​的​,通​过 Configuration, CacheJmxWrapper 可​以​构​建​、​创​建​和​启​动​缓存。​对​于​微​容​器​来​说​, 这​是​首​选​的​方​法
, 因​为​它​保​留​了​创​建​ CacheFactory 所​需​的​样​板​ XML 文​件​。
----
<?xml version="1.0" encoding="UTF-8"?>
<deployment xmlns="urn:jboss:bean-deployer:2.0">
<!-- First we create a Configuration object for the cache -->
<bean name="ExampleCacheConfig"
class="org.jboss.cache.config.Configuration">
... build up the Configuration
</bean>
<bean name="ExampleCache" class="org.jboss.cache.jmx.CacheJmxWrapper">
<annotation>@org.jboss.aop.microcontainer.aspects.jmx.JMX
(name="jboss.cache:service=ExampleTreeCache",
exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class,
registerDirectly=true)</annotation>
<constructor>
<parameter><inject bean="ExampleCacheConfig"/></parameter>
</constructor>
</bean>
</deployment>
----

* 5.3.3 JBoss Cache 的统计信​息 

  JBoss Cache 捕​捉​拦​截​器​和​其​他​组​件​的​统​计​信​息​,并​通​过​一​系​列​ MBean 开​放​这​些​信​息​。​收​集​统​计​信​息​缺​省是​启​用​的​;对​于​某​个​缓​存​实​例​,它​可​以​通​过​ Configuration.setExposeManagementStatistics() setter 禁​用​。​请​注​意​, 统​计​信​息​主​要​是​由​ CacheMgmtInterceptor 提​供​的​,所​以​这​个​拦​截​器​从​这​个​角​度来​说​是​最​重​要​的​。​如​果​基​于​性​能​考​虑​, 你​想​禁​用​所​有​的​统​计​信​息​, 你​应​该​利​用 Configuration.setExposeManagementStatistics(false) 配​置​, 因​为​它​可​以​阻​止​缓​存​启​动​时​在拦​截​器​栈​里​包​含​ CacheMgmtInterceptor。

  如​果​ CacheJm xWrapper 在​ JMX 里​进​行​了​注​册​,wrapper 也​会​确​保​开​放​统​计​信​息​的​每​个​拦​截​器​和​组​件​都在​ JMX 里​注​册​一​个​ MBean。然​后​管​理​工​具​就​可​以​访​问​那​些​ MBean 以​查​看​统​计​信​息​。​请​参​考​『​第 13.1 节 “JBoss Cache 的​统​计​信​息​”』章​节​里​关​于​通​过​ JMX 可​用​的​统​计​信​息​方​面​的​内​容​。

* 5.3.4 接收​ JMX 通​知 

  如​『​第 2.7 节 “添​加​缓​存​ Listener - 注​册​缓​存​事​件​”』​章​节​里​所​述​,JBoss Cache 用​户​可​以​注​册​一​个​ listener 来​接​收​缓​存​事​件​。​用​户​可​以​利​用​缓​存​的​管​理​信​息​结​构​来​接​收​这​些​事​件​(JMX 通​知​)。​通​过​注​册​用​于 CacheJmxWrapper 的​ NotificationListener, 缓​存​事​件​可​以​作​为​通​知​访​问​。

  关​于​可​通​过​ CacheJm xWrapper 接​收​的​ JMX 通​知​列​表​,请​参​考​『​第 13.2 节 “JMX MBean 通​知​”』​。

  下​面​是​一​个​在​ JBoss 应​用​服​务​器​环​境​里​通​过​程​序​获​取​缓​存​通​知​的​例​子​。​在​这​个​例​子​里​,客​户​使​用​了​一​个​过​滤器​来​指​定​所​关​心​的​事​件​。
----
MyListener listener = new MyListener();
NotificationFilterSupport filter = null;
// get reference to MBean server
Context ic = new InitialContext();
MBeanServerConnection server =
(MBeanServerConnection)ic.lookup("jmx/invoker/RMIAdaptor");
// get reference to CacheMgmtInterceptor MBean
String cache_service = "jboss.cache:service=TomcatClusteringCache";
ObjectName mgmt_name = new ObjectName(cache_service);
// configure a filter to only receive node created and removed events
filter = new NotificationFilterSupport();
filter.disableAllTypes();
filter.enableType(CacheNotificationBroadcaster.NOTIF_NODE_CREATED);
filter.enableType(CacheNotificationBroadcaster.NOTIF_NODE_REMOVED);
// register the listener with a filter
// leave the filter null to receive all cache events
server.addNotificationListener(mgmt_name, listener, filter, null);
// ...
// on completion of processing, unregister the listener
server.removeNotificationListener(mgmt_name, listener, filter, null);
----

  下​面​是​在​前​面​例​子​里​使​用​的​简​单​的​通​知​ listener 的​实​现​。

----
private class MyListener implements NotificationListener, Serializable
{
public void handleNotification(Notification notification, Object handback)
{
String message = notification.getMessage();
String type = notification.getType();
Object userData = notification.getUserData();
System.out.println(type + ": " + message);
if (userData == null)
{
System.out.println("notification data is null");
}
else if (userData instanceof String)
{
System.out.println("notification data: " + (String) userData);
}
else if (userData instanceof Object[])
{
Object[] ud = (Object[]) userData;
for (Object data : ud)
{
System.out.println("notification data: " + data.toString());
}
}
else
{
System.out.println("notification data class: " +
userData.getClass().getName());
}
}
}
----

  注​意​:JBoss Cache 管​理​实​现​只​在​客​户​注​册​ MBean 通​知​接​收​时​才​侦​听​缓​存​事​件​。​只​要​没​有​客​户​注​册, MBean 就​不​会​充​当​缓​存​ listener。

* 5.3.5 用 ​jconsole 访​问​独​立​环​境​里​的​缓​存 ​MBean

  如​果​缓​存​实​例​运​行​在​提​供​ MBean 服​务​器​接​口​(如​ JBoss JMX 控​制​台​)的​应​用​服​务​器​里​,JBoss Cache MBean 是​很​容​易​可​以​被​访​问​的​。​关​于​如​何​访​问​运​行​在​服​务​器​的​ MBean 容​器​里​的​ MBean 的​说​明​,请​参​看​服务​器​文​档​ [1]。

  此​外​,如​果​运​行​在​非​服​务​器​环​境​里​,JBoss Cache MBean 也​可​以​使​用​ jconsole 访​问​。​当​在​应​用​服​务​器​外部​运​行​独​立​缓​存​时​,你​可​以​按​如​下​方​法​访​问​缓​存​的​ MBean。
. 当​启​动​缓​存​将​在​其​中​运​行​的​ JVM 时​,设​置​系​统​属​性​ -Dcom .sun.m anagem ent.jm xrem ote。
. 一​旦​ JVM 开​始​运​行​,启​动​ JDK 的​ /bin 目​录​下​的​ jconsole 程​序​
. 然​后​,你​可​以​选​择​ JVM 并​进​行​连​接​。​在​ MBean 面​板​里​你​将​看​到​可​用​的​ JBoss Cache MBean

  注​意​:当​连​接​到​运​行​ JBoss Cache 实​例​的​ JVM 时​,jconsole 将​自​动​注​册​为​侦​听​缓​存​通​知​的​ listener。


6 各​版​本​的​兼​容​性​和​互​用​性
+++++++++++++++++++++

* 6.1 API 的兼容性 

  通​常​来​说​,在​主​要​的​ JBoss Cache 发​行​版​本​是​兼​容​和​可​互​用​的​。​兼​容​性​是​指​应​用​程​序​的​升​级​只​需​要​简​单​地替​换​ jar 文​件​就​够​了​。​而​互​用​性​则​意​味​着​两​个​不​同​版​本​的​ JBoss Cache 可​用​在​同​一​群​集​里​,它​们​应​该​能​够​交换​复​制​和​状​态​转​移​信​息​。​要​注​意​的​是​,互​用​性​要​求​在​群​集​中​的​所​有​节​点​里​使​用​相​同​的​ JGroups 版​本​。​在​多数​情​况​下​,某​个​ JBoss Cache 版​本​所​使​用​的​ JGroups 能​够​进​行​升​级​。 JBoss Cache 2.x.x 不​能​ API 或​二​进​制​兼​容​以​前​的​ 1.x.x 版​本​。​从​另​一​方​面​来​说​,JBoss Cache 2.1.x 和​ 2.0.x 可​以​ API 和​二​进​制​兼​容​。 JBoss Cache 3.x 和​ 2.x 二​进​制​以​及​ API 兼​容​,但​我​们​仍​推​荐​不​要​在​客​户​端​代​码​里​使​用​已​取消​的​方​法​、​类​和​配​置​文​件​。

* 6.2 线​级​(Wire-level)互​用​性 

  你​可​以​配​置​属​性​ Configuration.setReplicationVersion() 来​控​制​缓​存​间​通​讯​的​线​格​式​。​在​和​旧版​本​通​讯​时​,它​们​可​从​更​高​效​和​更​新​的​协​议​转​换​为​”​兼​容​“​的​版​本​。​这​个​机​制​允​许​我​们​在​使​用​高​效​的​有​线​格​式的​同​时​,又​能​够​保​持​互​用​性​,从​而​改​进​了​ JBoss Cache。

* 6.3. 兼容性矩​阵 

  JBoss Cache 网​站​上​维​护​着​兼​容​性​矩​阵​ [1],它​包​含​了​ JBoss Cache、​JGroups 和​ JBoss Application Server 的​同​版​本​的​信​息​。
