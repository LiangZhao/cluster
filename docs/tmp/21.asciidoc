API
---

这部分包括两部分，通道 API 及构建快 API

通道 API
^^^^^^^^
这部分我们介绍构建可靠群组通信的 JGroups 类，我们主要集中于创建的使用通道。所以这些类位于 org.jgroups 包中，详细的介绍可参看 JGroups javadoc 文档。

1 工具类
++++++++
org.jgroups.util.Util 包含许多实用的的方法，我们可以使用这些方法来简化我们的代码。

*  objectToByteBuffer(), objectFromByteBuffer()
第一种方法需要一个对象作为参数，序列化到一个字节缓冲区（该对象是可序列化或实现 externalizable 接口）。字节数组，然后返回。这种方法通常用于将对象序列化为字节缓冲区的消息。第二种方法返回一个重建的对象从一个缓冲区。这两种方法都抛出一个异常，如果该对象不能被序列化和反序列化。

* objectToStream(), objectFromStream()
第一种方法需要一个对象，并将其写入到输出流。第二种方法需要输入流中读取对象。这两种方法都抛出一个异常，如果该对象不能被序列化和反序列化。

2 接口
++++++
接口被后面的一些实现使用所以我们先介绍 JGroups 通道接口。

* MessageListener
MessageListener提供接收回调消息，获取和设定群组状态，通过流的形式获取和设定状态。
----
public interface MessageListener {
    void receive(Message msg);
    void getState(OutputStream output) throws Exception;
    void setState(InputStream input) throws Exception;
}
----
当一个消息接收时 receive（）方法被调用。getState（）和 setState（）方法用来获取和设置组状态，例如有成员加入到组或有成员离开组时需要重新设定状态。

* MembershipListener
MembershipListener 接口与 MessageListener 接口类似：每当一个新的视图，怀疑消息，或块事件接收，对应的 MembershipListener 方法的实现将被调用。
----
public interface MembershipListener {
    void viewAccepted(View new_view);
    void suspect(Address suspected_mbr);
    void block();
    void unblock();
}
----
通常情况回调实现类需要实现 viewAccepted() 方法，当新的成员加入群组，或已存在的成员离开群组或已存在的成员发生异常时通知接收者。当有成员被怀疑（发生异常）时 suspect() 方法被调运。

block() 方法用来通知组成员被阻止发送消息，这个具体是 FLUSH 协议完成的，比如在群组状态转换或视图在初始化过程中调运此方法来阻止成员发送消息。当 block() 方法被调运，所以成员的线程都被阻止发送消息，直到 FLUSH 调运 unblock() 方法来释放这些线程。

unblock() 方法用来通知组成员 FLUSH 协议已经完成，成员可以发送消息。

* Receiver
----
public interface Receiver extends MessageListener, MembershipListener {
}
----
Receiver 用来处理接收消息或视图发生变化等，当有消息接收到时 receive() 方法被调运，任何时候当视图发生变化时 viewAccepted() 方法被调运。

* ReceiverAdapter
这个类实现了 Receiver 接口，所有实现方法为空，应用方法如果想实现回调我们需要继承 ReceiverAdapter，重写相关方法，通常我们实现receive() 方法和 viewAccepted() 方法。ReceiverAdapter 明细如下;
----
public class ReceiverAdapter implements Receiver {
	public void receive(Message msg) {}
	public void getState(OutputStream output) throws Exception {}
	public void setState(InputStream input) throws Exception {}
	public void viewAccepted(View view) {}
	public void suspect(Address mbr) {}
	public void block() {}
	public void unblock() {}
}
----

* ChannelListener
----
public interface ChannelListener {
	void channelConnected(Channel channel);
	void channelDisconnected(Channel channel);
	void channelClosed(Channel channel);
}
----
一个类实现 ChannelListener 可以使用 Channel.addChannelListener（）方法来注册获来获取通道状态的变化信息。当一个通道被关闭，断开或开启，相应的方法会被调用。 

3 Address
++++++++++
一个群组中的每个成员都有一个地址，它唯一标识成员。抽象这样的地址的接口是 Address，该地址需要具体的实现比较，排序等相关接口，JGroups的地址必须实现以下接口：
----
public interface Address extends Streamable, Comparable<Address>, Externalizable{
int size();
} 
----
为了序列化及反序列化方便，size() 方法需要返回的地址实现的一个实例序列化形式占用的字节数。不要使用直接实现 Address，Address 作为一个不透明的集群节点的标识符！

实际上 Address 的实现需要依赖底层的通信协议（例如，UDP或TCP），这允许被使用的JGroups为所有可能的各种地址。由于一个地址唯一的标识一个通道，群组中的成员也是通过地址来发送消息到组中其他成员。

Address 的默认实现是 org.jgroups.util.UUID，它唯一标识节点，断开并重新连接到群集时，一个节点被赋予了新的 UUID。UUID 是不会直接显示出来，但通常显示为一个逻辑名称（之后会消息介绍逻辑名称）。这个名字可以通过用户或 JGroups，其唯一的目的是为了使日志输出的更具可读性。UUID 映射到 IP 地址和端口号，这些最终被传输协议用来来发送消息。

4 Message
+++++++++
群组中成员之间以消息（org.jgroups.Message）的形式发送数据。一个成员可以发送一条消息给群组中的一个成员，也将这条消息发送给群组中的所有成员，群组中的所以成员共享一个通道。如下图为消息的结构示意图：

image::img/2-1.png[消息结构图]

一条消息可以分为五个部分：

* 目的地址
接收机的地址。如果为空，该消息将被发送到所有当前的组成员。Message.getDest（）返回消息的目的地地址。

* 源地址
发送者的地址。可以保留为空，如果为空，该字段将会由传输协议（如UDP）在将消息发送到网络上之前填写。

* 标志符
大小为一个字节。目前可识别的标志符有 OOB，DONT_BUNDLE，NO_FC，NO_RELIABILITY，NO_TOTAL_ORDER，NO_RELAY 和 RSVP。稍候我们将会做详细的讨论。

* 有效负载
实际的数据（以字节缓冲区的形式）。Message类包含方便的方法来设置一个序列化的对象，并检索了一遍，使用序列化将对象转换到/从一个字节缓冲区。如果缓冲区的子范围较大的缓冲区，一个消息会有一个偏移量和长度。

* 消息头
可以有一个队列的消息有连接到一个消息，任何不能够在有效负载中的信息可以作为消息头。方法putHeader（），getHeader（）和removeHeader（）的消息可以用于操纵控制消息头。需要声明，消息头是内部协议实现时做封装调运，应用程序代码不能够添加或删除消息头。

一条消息，是类似的一个IP包的有效载荷（一个字节缓冲器）和发送者和接收者（如地址）的地址组成。可以把网络上的任何消息路由到其目的地（接收地址），反馈消息可以返回到发送者的地址。

一条消息，通常并不需要填写发件人的地址发送邮件时，这是由协议栈将消息发送到网络上之前自动完成的。然而，可能存在这样的情况，当该消息的发送者希望得到一个从它自己的不同的地址，例如反馈消息发送到其他成员。

目标地址（接收器）可以是一个地址，表示一个成员的地址，例如确定从收到的消息，也可以是空的，这意味着该消息将被发送到该组的所有成员。一个典型的多播消息，发送字符串“Hello”的所有成员将看起来像这样：
----
Message msg=new Message(null, "Hello");
channel.send(msg);
----

5 Header
++++++++
如上消息头是一个自定义的一个字节大小的信息，可以被添加到每个消息。JGroups的广泛使用消息头，例如添加序列号到每个消息（NAKACK 和 UNICAST），因此这些消息可以按照顺序发送。

6 Event
+++++++
事件使 JGroups 协议栈之间可以相互交换信息，相比较消息，消息是群组中成员通过网络传输，而时间是在协议栈中由上到下或由下到上传输。

NOTE: 消息头和时间都是被 JGroups 内部协议栈使用，外部应用程序不能够调运这些接口。

7 View
++++++
视图（org.jgroups.View）是一个群组中所有成员的列表。它由一个唯一标识自己的 ViewId 和所有成员的列表组成。每当有新的成员加入或现有的叶子（或崩溃），视图就会被通道下层的协议栈自动重新安装。一个群组中的所有成员看到的视图是相同的。

需要注意，视图中的第一个成员是协调者，因此群组中的成员可以很容易找到协调者而不需要与其他成员交互信息，任何情况视图中的第一个成员被认为是协调者。

下面的代码显示了如何发送（单播）消息给视图中的第一个成员：
----
View view = channel.getView();
Address first = view.getMembers().get(0);
Message msg = new Message(first, "Hello world");
channel.send(msg);
---- 

* ViewId
ViewId 是用来唯一标识视图，它包括的视图创建者的地址和一个序列号，ViewId 可以比较大小（实现了 equals（）和hashCode（））使用 HashMap 来保存。

* MergeView
每当一组分裂成子类，例如由于网络分区，后面的子群合并到一起，这种情况一个 MergeView 代替 View 将被应用程序使用。MergeView 是 View 的一个子类，包含一些视图合并所需的变量，例如，视图 V1:(p,q,r,s,t) 分裂成 V2:（p,q,r）和 V2:（s,t），合并的视图可能是 V3:（p,q,r,s,t) ，在这种情况下 MergeView 包含变量 V2:（p,q,r）和 V2:（s,t）。

8 JChannel
++++++++++
一个应用成员为了加入一个群组发送消息，首先它需要创建一个通道。通道是像一个插座。当客户端连接到一个通道，它给它想加入的群组一个名称。因此，通道（在其连接状态）总是与一个特定的组相关联。协议栈同样需要这个组的名字来找到彼此：当一个客户端连接到一个通道给定组的名称为 G，接着它会尝试找到具有相同名称的现有通道，并加入他们，这样一个新的视图是被安装（包含新的成员）。如果没有成员的存在，将创建一个新的组。

下图为通道主要状态变化示意图：

image::img/2-2.png[通道主要状态]

当第一次创建一个通道，它是在未连接状态。如果通道在未连接状态执行某些特定方法（如发送/接收消息）会抛出异常。如果有客户端成功连接到通道，通道变为连接状态。在连接状态，通道可以接收/发送消息，同时也会收到通道中成员离开或新成员加入的通知消息。当通道断开，允许其返回到未连接状态。一个连接和未连接的通道都可以被关闭，这样设计也是为了通道的可重利用。当通道处于关闭状态，任何方法尝试操作通道都会抛出异常。当出于连接状态的通通执行关闭操作，首先通道变为未关闭状态，然后到关闭状态。

接下来我们列出所以操作通道的方法，通过这些方法我们可以明细通道状态的变化：

* 创建通道
我们可以通过通道的构造方法创建一个通道。最被常用的方法如下：
----
public JChannel(String props) throws Exception;
----

props 参数指向一个 XML 文件，该文件定义了通道所使用的协议栈信息。如下为常见代码端：
----
JChannel ch = new JChannel("/home/bela/udp.xml");
----

如果道具参数为null，默认的属性将被使用。如果无法创建通道，将会抛出一个异常。可能的原因包括协议中指定的属性参数，但没有被发现，或错误的协议参数。其他可选的构造方法如下：
----
public JChannel() throws Exception
public JChannel(File properties) throws Exception
public JChannel(Element properties) throws Exception
public JChannel(URL properties) throws Exception
public JChannel(ProtocolStackConfigurator configurator) throws Exception
public JChannel(JChannel ch) throws Exception 
----

如下为 XML 文件示例：
----
<config xmlns="urn:org:jgroups"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="urn:org:jgroups http://www.jgroups.org/schema/JGroups-3.1.xsd">
    <UDP
         mcast_port="${jgroups.udp.mcast_port:45588}"
         tos="8"
         ucast_recv_buf_size="20M"
         ucast_send_buf_size="640K"
         mcast_recv_buf_size="25M"
         mcast_send_buf_size="640K"
         loopback="true"
         discard_incompatible_packets="true"
         max_bundle_size="64K"
         max_bundle_timeout="30"
         ip_ttl="${jgroups.udp.ip_ttl:8}"
         enable_bundling="true"
         enable_diagnostics="true"
         thread_naming_pattern="cl"

         timer_type="new"
         timer.min_threads="4"
         timer.max_threads="10"
         timer.keep_alive_time="3000"
         timer.queue_max_size="500"

         thread_pool.enabled="true"
         thread_pool.min_threads="2"
         thread_pool.max_threads="8"
         thread_pool.keep_alive_time="5000"
         thread_pool.queue_enabled="true"
         thread_pool.queue_max_size="10000"
         thread_pool.rejection_policy="discard"

         oob_thread_pool.enabled="true"
         oob_thread_pool.min_threads="1"
         oob_thread_pool.max_threads="8"
         oob_thread_pool.keep_alive_time="5000"
         oob_thread_pool.queue_enabled="false"
         oob_thread_pool.queue_max_size="100"
         oob_thread_pool.rejection_policy="Run"/>

    <PING timeout="2000"
            num_initial_members="20"/>
    <MERGE2 max_interval="30000"
            min_interval="10000"/>
    <FD_SOCK/>
    <FD_ALL/>
    <VERIFY_SUSPECT timeout="1500"  />
    <BARRIER />
    <pbcast.NAKACK2 xmit_interval="1000"
                    xmit_table_num_rows="100"
                    xmit_table_msgs_per_row="2000"
                    xmit_table_max_compaction_time="30000"
                    max_msg_batch_size="500"
                    use_mcast_xmit="false"
                    discard_delivered_msgs="true"/>
    <UNICAST  xmit_interval="2000"
              xmit_table_num_rows="100"
              xmit_table_msgs_per_row="2000"
              xmit_table_max_compaction_time="60000"
              conn_expiry_timeout="60000"
              max_msg_batch_size="500"/>
    <pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000"
                   max_bytes="4M"/>
    <pbcast.GMS print_local_addr="true" join_timeout="3000"
                view_bundling="true"/>
    <UFC max_credits="2M"
         min_threshold="0.4"/>
    <MFC max_credits="2M"
         min_threshold="0.4"/>
    <FRAG2 frag_size="60K"  />
    <RSVP resend_interval="2000" timeout="10000"/>
    <pbcast.STATE_TRANSFER />
    <!-- pbcast.FLUSH  /-->
</config>
----

如上一个协议栈由<config></config>元素包裹，该元素列出所有协议，从最底部的协议（UDP）到顶部协议（STATE_TRANSFER）。每一个元素定义了一个协议。

每一种协议都由一个Java类实现。当创建基于上述 XML 配置的协议栈，第一个元素（“UDP”）成为最下层的协议，第二个元素被至于元素（“UDP”）之上，类似堆栈协议创建将从底部到顶部。

协议栈中的每一个元素都有一个 Java 类，这些类位于 org.jgroups.protocols 包中。请注意，只有基本名称必须符合，而不是完全指定的类名（UDP，而非 org.jgroups.protocols.UDP）。如果没有找到，协议类的 JGroups 假设给定的名称是一个完全合格的类名，因此将尝试实例化这个类。如果这不起作用抛出一个异常。这使得协议类可以存在于不同的包，例如：一个有效的协议的名称可能是 com.sun.eng.protocols.reliable.UCAST。

每一层可以有零个或多个参数，这些参数在协议名称后括号中括号中以 key/value 的形式指定。在上面的例子中，UDP被配置一些选项，其中之一是IP组播端口（mcast_port）被设置为45588（如果没有使用系统参数 jgroups.udp.mcast_port 指定）。

另为在一个群组中的所有成员必须使用相同的协议栈。

通常情况下，通道是通过传递一个 XML 配置文件的名称给 JChannel（）构造函数来创建。除本声明的配置，JGroups 提供的API以编程方式创建一个通道。以这种方式首先是创建一个 JChannel，然后实例化一个 ProtocolStack，然后添加所有所需的协议到 ProtocolStack，最后调用init（）在堆栈中设置它。如下是一个使用 JGroups API 创建通道的例子：
----
 27 public class ProgrammaticChat {
 28 
 29         static final String BIND_ADDR = "192.168.1.101" ;
 30 
 31         public static void main(String[] args) throws Exception {
 32 
 33                 JChannel channel = new JChannel(false);
 34                 ProtocolStack stack = new ProtocolStack();
 35                 channel.setProtocolStack(stack);
 36 
 37                 stack.addProtocols(new UDP().setValue("bind_addr", InetAddress.getByName(BIND_ADDR)))
 38                                 .addProtocol(new PING())
 39                                 .addProtocol(new MERGE2())
 40                                 .addProtocol(new FD_SOCK())
 41                                 .addProtocol(new FD_ALL().setValue("timeout", 12000).setValue("interval", 3000))
 42                                 .addProtocol(new VERIFY_SUSPECT()).addProtocol(new BARRIER())
 43                                 .addProtocol(new NAKACK()).addProtocol(new UNICAST2())
 44                                 .addProtocol(new STABLE()).addProtocol(new GMS())
 45                                 .addProtocol(new UFC()).addProtocol(new MFC())
 46                                 .addProtocol(new FRAG2());
 47                 stack.init();
 48 
 49                 channel.setReceiver(new ReceiverAdapter(){
 50 
 51                         public void receive(Message msg) {
 52                                 Address sender=msg.getSrc();
 53                                 System.out.println(msg.getObject() + " [" + sender + "]");
 54                         }
 55 
 56                         public void viewAccepted(View view) {
 57                                 System.out.println("view: " + view);
 58                         }});
 59 
 60                 channel.connect("ChatCluster");
 61 
 62                 for (;;) {
 63                         String line = Util.readStringFromStdin(": ");
 64                         channel.send(null, line);
 65                 }
 66 
 67         }
 68 
 69 }
----

33 行实例化一个通道，并传递一个 false 参数，这表明创建通道不需要实例化协议栈；34 行实例化自定义的协议栈；37-46 行使用 API 添加协议。注意添加的顺序（（由最低层传输协议到最顶层FRAG2），每个协议提供了set/get方法来设定参数，当然也可以使用 setValue(String attr_name, Object value)来设定相关参数的值；47 行所示，当协议栈配置完成，我们通过 ProtocolStack.init() 初始化协议栈；至此由编程的方式创建通道完成。

* 给通道一个逻辑名称
通道可以指定一个逻辑名称。如果 JGroups 的逻辑名称没有被设置，则会自动生成一个，使用主机名和一个随机数，例如 localhost-35655。逻辑名称设定可以通过如下方法设定：
----
public void setName(String logical_name);
----

设定逻辑名必须要在连接通道之前进行，逻辑名设定后知道通道被销毁一直存在，如下为 JGroups 启动时显示设定的通道逻辑名：
----
GMS: address=JBoss Cluster, cluster=JChannelLogicNameTest, physical address=192.168.1.101:47094
----

如上通道逻辑名为 JBoss Cluster，物理地址为 192.168.1.101:47094

* 自定义地址
我们可以自定义地址，这意味着，应用程序可以决定它使用什么样的地址。默认地址类型的 UUID，因为一些协议使用的 UUID，可以通过继承 UUID 来自定义自己的地址。这可以用来传递额外的数据通过地址，例如我们可以传递节点位置通过自定义地址。需要注意父类 UUID 中 equals(), hashCode() 及 compare() 则不需要改变。

* 加入到一个群组
当客户端要加入集群，它连接到一个通道通过要加入群集的名称： 
----
public void connect(String cluster) throws Exception;
----

群集名称是要加入群集的名称。所有通道，调用connect（）具有相同的名称，组成一个集群。集群中的任何通道上发送的消息，所有成员都能够收到。connect（）方法一旦连接成功将会返回。如果通道在关闭状态，调运 connect（）方法将会抛出异常。如果没有其他成员，即没有其他的成员连接到集群使用这个名字，然后一个新的群集创建和加入它作为第一个成员。在群集的第一个成员成为小组的协调员。协调器是负责当群组成员发生变化时安装新的视图。

* 在加入集群时获取一个成员的状态
客户端还可以加入集群，并在一次操作中获取集群状态。最好的方式来概念化的连接和获取状态的连接方法是把它作为一个常规的connect（）和有getstate（）连续执行的方法。然而，使用的连接，并获取定期连接状态连接方法有几个优点。首先，底层的消息交换是高度优化的，特别是如果使用 FLUSH 协议。但更重要的是，从客户的角度来看，连接和获取状态操作成为一个原子操作。
----
public void connect(String cluster, Address target, long timeout) throws Exception;
----
就像在一个普通的connect（），群集名称代表要加入集群。target 参数表示要获取状态的集群成员，如果 target 参数为空则表示获取群集中协调者的状态。timeout 参数表示加入群集和获取状态的时间，如果超过此时间则抛出异常。

* 获取本地地址和集群的名称
方法getAddress（）返回的地址的通道。当通道处于未连接状态时，该连接不可用。
----
public Address getAddress();
----

方法 getClusterName（）方法返回群集的名称。
----
public String getClusterName();
----

* 获取当前群集视图
使用如下方法可以获取当前状态的视图：
----
public View getView();
----

该方法获得当前通道的视图，视图在当有新成员加入或现有成员离开时发生变化。如果通道出于关闭或未连接状态时调运此方法返回空值。

* 发送消息
一旦客户连接到通道，我们可以使用下面中的任何一个 send() 方法发送消息：
----
public void send(Message msg) throws Exception
public void send(Address dst, Object obj) throws Exception
public void send(Address dst, byte[] buf) throws Exception
public void send(Address dst, byte[] buf, int offset, int length) throws Exception
----

第一send（）方法只有一个参数，就是要发送的消息。消息的目的地即可以是接收器的地址（单播）或空（多播）。当目标为空，则该消息将被发送到群集中的所有成员（包括其本身）。其它send（）方法即可以发送字节数组也可以发送实现了序列化的对象。如果通道状态为关闭或未连接状态，发送方法或抛出异常。如下：
----
channel.send(null, data);
----

目的地址为空值意味着该消息将被发送到集群中的所有成员。当然我们也可以将消息发送到特定的成员：
----
Address receiver = channel.getView().getMembers().get(0);
channel.send(receiver, "hello world");
----

如上我们给集群的协调者（视图中的第一个成员）发送 hello world 字符串。

我们可以通过如下方法不给自己发送消息：
----
JChannel.setDiscardOwnMessages(boolean flag)
----

虽然JGroups的担保，消息最终会被送到在所有非故障的成员，有时这可能需要一段时间。例如，如果我们有一个重传协议负责确认，并当发送最后一条消息丢失，那么接收器将不得不等待，直到通知该消息已丢失，然后才可以重发。这是可以通过设置 Message.RSVP 标志：遇到这个标志时，消息发送阻塞，直到所有成员都确认接收消息。这也可作为另一个目的：如果我们发送一个有 RSVP 标记的消息，接着当 send（）方法返回，我们确保所有成员接收消息。请注意，因为 RSVP 消息是昂贵的，可能会阻止发送者一段时间，它应该被谨慎使用。

要使用RSVP，必须做两件事情：
首先 首先，RSVP 协议要在协议栈的配置中，如下：
----
<config>
<UDP/>
<PING />
<FD_ALL/>
<pbcast.NAKACK use_mcast_xmit="true"
discard_delivered_msgs="true"/>
<UNICAST timeout="300,600,1200"/>
<RSVP />
<pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000"
max_bytes="4M"/>
<pbcast.GMS print_local_addr="true" join_timeout="3000"
view_bundling="true"/>
...
</config>
----

其次，我们想要得到的同步确认的消息必须有设定 RSVP 标记：
----
Message msg=new Message(null, null, "hello world");
msg.setFlag(Message.RSVP);
ch.send(msg);
----

* 接收消息
通常，重写 ReceiverAdapter（或Receiver）中的 receive() 方法来负责处理接收消息。
----
public void receive(Message msg);
----

接收器可以通过通道使用JChannel.setReceiver（）来注册。所以接收消息，视图状态变化都可以通过重写 ReceiverAdapter（或Receiver）中方法来实现监听。如下代码端：
----
 49                 channel.setReceiver(new ReceiverAdapter(){
 50 
 51                         public void receive(Message msg) {
 52                                 Address sender=msg.getSrc();
 53                                 System.out.println(msg.getObject() + " [" + sender + "]");
 54                         }
 55 
 56                         public void viewAccepted(View view) {
 57                                 System.out.println("view: " + view);
 58                         }});
----

51 行为重写 ReceiverAdapter receive() 方法，当有消息接收到时，该方法被调运；56 行重写 viewAccepted() 方法，当视图发生改变（有成员加入或退出）时，该方法被调运。

* 获取集群的状态
新加入的成员在开始工作之前，可能要检索的集群状态。这可以通过 getstate()：
----
public void getState(Address target, long timeout) throws Exception;
----
此方法返回一个成员（通常是最年长的成员，即协调者）的状态。如果 target 参数为空则表示获取群集中协调者的状态。timeout 参数表示获取状态的时间，如果超过此时间则抛出异常。如果 timeout 参数值设为 0 则表示一直等待直到操作完成。
// come soon

* 断开通道连接
断开一个通道是通过使用下面的方法来完成：
----
public void disconnect();
----
如果通道已经在断开或闭合的状态下，它不会有任何效果。如果连接时，它会离开集群会通过发送离开请求到目前的协调员。后者也将随之从视图中删除离开的节点，并安装一个新的视图中所有剩余的成员。断开连接成功后，该通道将是在未连接的状态下，可能会在日后重新连接。

* 关闭通道
要关闭释放一个通道实例（销毁相关联的协议栈，并释放所有的资源），使用 close（）方法：
----
public void close();
----

关闭连接的通道，先断开通道。close（）方法使通道出于关闭状态，通道出于关闭状态时没有进一步的操作是允许的。在这种状态下，通道实例不考虑再被任何一个应用程序使用。最终 JVM 垃圾回收器会释放通道使用的内存。
