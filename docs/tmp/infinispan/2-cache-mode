1. 缓存模式
Infinispan提供了两种模式：
-本地模式 - Infinispan提供的非集群的模式，在本地模式下，Infinispan可看作是一个单节点的，在内存中的数据缓存。与集群模式相比，因为我们不会考虑集群的可扩展性，容错能力，等，这使得Infinispan性能更高，使用更高效。
-集群模式 - 集群模式是多个Infinispan服务器（Infinispan实例）组成一个集群，集群中所有点构成一个数据网格。网格中某一节点的状态需要复制到其他所有节点，或节点的一个子集上。这个子集中节点数的多少确定了Infinispan数据网格的容错能力和可扩展性，子集节点数太大会阻碍Infinispan网格的可扩展性。集群模式中节点之间是通过JGroups来复制状态，我们在后面会做详细讨论。根据复制策略的不同，集群模式又可分为分布式模式，复制模式和无效模式

1.1 本地模式
尽管Infinispan主要特性体现在集群模式，Infinispan本地模式提供了需要实用高效的特性，Infinispan的Cache接口继承JDK的ConcurrentMap，和普通Map相比，Infinispan提供了如下特性：
- 缓存条目可通过缓存存储器保存到第三方存储服务器（关系数据库，No-SQL，云），并且可通过同步，异步的模式通过缓存存储器操作第三方存储服务器
- 缓存条目的逐出阻止Java虚拟机内存溢出
- 缓存条目的过期确保长时间未被使用的条目被移除
- JTA和XA支持使缓存操作有事务性的保证
- 基于MVCC的并发读处理确保缓存实体可被告诉的非阻塞的读取

1.2 Infinispan服务器的缓存容器
Infinispan服务器相当与一个缓存容器，容器中可以有多个缓存实体，这些缓存可以是本地的，也可以是集群的。Infinispan服务器提供协议（HotRod，Rest，Memcached）供客户端应用连接到服务器，对容器中的缓存进行操作。Infinispan服务器配置文件中cache-container属性表示缓存容器，这个属性中包括多个缓存的配置，包括本地缓存和集群缓存。如下为缓存容器简单配置，我们从JDG/standalone/configuration/standalone.xml中摘出。
<subsystem xmlns="urn:infinispan:server:core:5.3" default-cache-container="local">
	<cache-container name="local" default-cache="default" start="EAGER">
	</cache-container>
</subsystem>
cache-container包括如下属性
- name 确定了缓存容器的名字
- default-cache 确定了缓存容器默认使用的缓存实例
- start 确定是否在Infinispan服务器启动时加载缓存容器，该属性有效值可为EAGER或LAZY，如果为EAGER则Infinispan服务器启动时加载缓存容器，LAZY则在请求时加载

1.3 本地模式的配置
在Infinispan服务器中如下配置添加了本地缓存到缓存容器，如下：
<cache-container name="local" default-cache="default" >
    <local-cache name="default" start="EAGER">
        <locking isolation="NONE" acquire-timeout="30000" concurrency-level="1000" striping="false" />
        <transaction mode="NONE" />
    </local-cache>
</cache-container>
如上通过配置文件创建的本地缓存类似通过Infinispan 接口 DefaultCacheManager创建默认缓存。 另外，本地缓存和集群缓存可以同时位于cache-container中，但如果缓存容器中有集群缓存，则cache-container必须要有<transport/> 属性。local-cache元素包括如下属性和子元素：
- name 确定了本地缓存的名字
- start 确定缓存容器是否默认启动缓存实例，该属性有效值可为EAGER或LAZY，如果为EAGER则缓存容器启动时启动缓存实例，LAZY则表示只有在请求时加载
- batching 确定是否批处理操作本地缓存
- indexing 确定本地缓存的索引属性，该属性有效值可为NONE，LOCAL和ALL
另外在本地缓存中，如果我们通过Infinispan API加载缓存，例如通过DefaultCacheManager构造方法传递Infinispan配置文件创建缓存，如下为一示例Infinispan配置文件
<clustering mode="local" />
注意，如上为集群缓存配置模式指定local，在这种情况下，即使定义<transport/> 属性。

1.4 集群模式
根据状态复制策略的不同，集群模式又细分为：分布式模式，复制模式和无效模式，随后我们依次介绍。集群模式下我们可以进一步配置状态传输模式为同步或异步。
如果同步模式被使用，发送者阻塞等待接收者响应，直到发送者接收到响应线程才继续运行。而异步模式传输数据但不阻塞，不需要等待响应，这确保了集群的连续性。比如在Web应用集群中，负载均衡采用粘性会话的方式（sticky-session），请求都是到同一节点，这种情况我们使用异步模式复制HTTP会话状态。我们可以通过mode属性配置异步还是同步，如下示例配置为同步复制模式。
<replicated-cache name="default" start="EAGER" mode="SYNC" batching="false" >
...
</replicated-cache>
另为我们可以通过Infinispan提供的接口获取集群网格的物理地址：
AdvancedCache.getRpcManager().getT ransport().getPhysicalAddresses()


2. 分布式模式
Infinispan分布式模式是指缓存条目保存在网格节点的一个子集上，而不是网格中每个节点都保存一份缓存条目。通常为了数据的备份和网格的容错能力，缓存条目保存在两个或两个以上的节点上。和其他集群的模式相比，由于缓存条目保存在网格节点子集上，使得在可扩展性上优于其他模式。
infinispan_destribution.png[11-1 Infinispan分布式模式]
如图11-1所示，4台Infinispan服务器构建成一个4个节点的数据网格，保存缓存条目的子集为2。我们往服务器1上添加数据K/V，则哈希算法决定该数据保存在哪一个节点上，图中所示数据保存在了服务器2上。读取数据时，同样通过哈希算法到相应的节点上获取数据，图中所示我们在服务器3上获取缓存条目K/V。
Infinispan分布式模式中数据备份或数据保存在网格中一个子集上体现了Infinispan的可扩展性和大数据的特点。如下公式可以计算出Infinispan数据网格的容量：
---
Capacity = (memory * number) / numOwners
---
- Capacity - 数据网格的容量
- memory - 数据网格中单个节点的内存大小
- number - 数据网格中节点的个数
- numOwners - 数据网格中节点子集（数据备份或数据保存的节点数）
比如我们有50个节点的，每个节点上可供Infinispan使用的内存大小为4GB，数据网格中节点子集为2，则数据网格的容量为(4 * 50) / 2，即为100GB。
分布式模式使用连续性哈希算法，使得数据的读取具有透明性，接下来我们来探讨连续性哈希算法。
2.1 分布式模式的连续性哈希算法
Infinispan分布式模式通过连续性哈希算法从网格中选择出那些节点来保存缓存条目，节点总数就是数据网格中节点子集，哈希算法通过配置文件知道节点子集总数，同时它维护缓存条目一直存在于这个数的节点上。节点子集数的大小与Infinispan数据网格的性能和容错能力相关，节点子集数太大，即缓存条目保存在很多节点上会影响性能，但节点子集数太小又影响容错能力。
哈希算法还用来从网格中存取数据缓存数据，存取数据的过程中不是向所有节点发送多播请求，存取过程也不需要维护很繁多的元数据，一个PUT操作，只会产生网格中节点子集数（numOwners）个远程调运。一个GET操作只针对网格中某一个节点产生一次远程调运，在后台实质也是产生网格中节点子集数（numOwners）个调运，且这些调运是并发进行的，查询到的结果会返回给调运者。另为，在分布式模式下，不管配置的是同步调运还是异步调运，如果缓存条目不存在于本地时，同步调运请求用来从其他节点获取数据。
2.2 配置分布式模式
分布式模式属于Infinispan集群模式，在Infinispan服务器中配置分布式模式我们需要在缓存容器中添加配置如下：
---
<cache-container name="local" default-cache="default" >
    <distributed-cache name="default" mode="{SYNC/ASYNC}" segments="${NUMBER}" start="EAGER">
        <locking isolation="NONE" acquire-timeout="30000" concurrency-level="1000" striping="false" />
        <transaction mode="NONE" />
    </distributed-cache>
</cache-container>
---
distributed-cache元素通过如下信息配置分布式缓存：
- name 定义了缓存名字，同来唯一标识缓存
- mode 定义了集群缓存的模式，有效的值为SYNC和ASYNC
- segments 该属性是选择性的，它直到了网格的哈希端，它的推荐值为网格中节点总数乘以10，该属性的默认值为80
- start 确定缓存容器是否默认启动缓存实例，该属性有效值可为EAGER或LAZY，如果为EAGER则缓存容器启动时启动缓存实例，LAZY则表示只有在请求时加载
另外我们通过Infinispan API，使用CacheManager加载分布式模式缓存实例，加载过程中我们需要指定Infinispan配置文件，如下为以示例配置文件：
---
<clustering mode="dist">
    <sync replTimeout="${TIME}" />
    <stateTransfer chunkSize="${SIZE}" fetchInMemoryState="{true/false}" awaitInitialTransfer="{true/false}" timeout="${TIME}" />
    <transport clusterName="${NAME}" distributedSyncTimeout="${TIME}" strictPeerToPeer="{true/false}" transportClass="${CLASS}" />
</clustering>
---
clustering元素的mode属性定义了集群缓存为分布式模式。
sync元素的replTimeout属性指定了等待运程调运的最大超时时间。如果到超时时间还没有接收到远程调运的确认，则抛出异常。
stateTransfer元素定义了集群中状态转换是怎么样完成的，状态转换发生在集群中节点离开或新节点加入。该元素有如下属性：
- chunkSize 定义了批量处理对缓存条目的大小数，如果该属性值大于0，则批处理缓存条目数为该属性设定的数，如果该属性值小于会等于0，则禁用批处理。
- fetchInMemoryState 如果该属性值为true，则缓存启动时请求获取周围缓存实例中的数据，这个影响缓存加载的时间
- awaitInitialTransfer 如果fetchInMemoryState属性值为true，awaitInitialTransfer属性可以使第一次CacheManager.getCache()方法调运阻塞，直到缓存获取到相邻缓存实例中的数据。该属性应用与分布式模式和复制模式，默认值为true
- timeout 定义了最大等待获取相邻缓存实例中数据的超时时间，单位为毫秒，如果在超时时间内没有接收到相邻节点的返回，则缓存加载取消，抛出相应异常。
transport元素是缓存数据的传输配置，它有如下属性：
- clusterName 定义了集群的名字，节点只有定义相同的集群名字，才能够加入集群，构建Infinispan数据网格
- distributedSyncTimeout 定义了等待获取分布式锁的时间，这个分布式锁确保了缓存实例的状态交换，以及实时哈希分配缓存条目
- strictPeerToPeer 如果设定为true，如果缓存示例不存在，则复制操作失败，抛出异常；如果设定为false，如果缓存示例不存在，则复制操作忽略失败，只是做简单日志记录
- transportClass 定义了代表缓存传输的实现类
2.3 分布式模式中GET和PUT




3. 复制模式


4. 无效模式


5. 缓存的写模式
